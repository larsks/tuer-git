{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}{\f4\froman\fprq0\fcharset1 Lucida Sans;}{\f5\froman\fprq0\fcharset1 DejaVu Serif;}{\f6\fswiss\fprq0\fcharset1 DejaVu Sans;}{\f7\froman\fprq0\fcharset1 DejaVu Sans;}{\f8\fnil\fprq2\fcharset0 DejaVu Sans;}{\f9\fnil\fprq2\fcharset1 Lucidasans;}{\f10\fnil\fprq0\fcharset1 Lucidasans;}{\f11\fswiss\fprq0\fcharset1 FreeSans;}{\f12\fnil\fprq0\fcharset1 DejaVu Sans;}{\f13\fnil\fprq0\fcharset1 Lucida Sans;}{\f14\fnil\fprq0\fcharset1 Mincho{\*\falt msmincho};}}
{\colortbl;\red0\green0\blue0;\red128\green128\blue128;}
{\stylesheet{\s0\snext0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036 Normal;}
{\s15\sbasedon0\snext16\ql\widctlpar\sb240\sa120\keepn\ltrpar\dbch\af8\langfe1033\dbch\af12\afs28\loch\f6\fs28\lang1036 Titre;}
{\s16\sbasedon0\snext16\ql\widctlpar\sb0\sa120\ltrpar\dbch\af8\langfe1033\dbch\af12\afs24\loch\f5\fs24\lang1036 Corps de texte;}
{\s17\sbasedon16\snext17\ql\widctlpar\sb0\sa120\ltrpar\dbch\af8\langfe1033\dbch\af6\afs24\loch\f5\fs24\lang1036 Liste;}
{\s18\sbasedon0\snext18\ql\widctlpar\sb120\sa120\noline\ltrpar\i\dbch\af8\langfe1033\dbch\af11\afs24\ai\loch\f5\fs24\lang1036 L\u233\'e9gende;}
{\s19\sbasedon0\snext19\ql\widctlpar\noline\ltrpar\dbch\af8\langfe1033\dbch\af6\afs24\loch\f5\fs24\lang1036 Index;}
{\s20\sbasedon0\snext20\ql\widctlpar\sb120\sa120\ltrpar\i\dbch\af8\langfe1033\dbch\af12\afs24\ai\loch\f5\fs24\lang1036 caption;}
{\s21\sbasedon0\snext21\ql\widctlpar\sb240\sa120\keepn\ltrpar\dbch\af8\langfe1033\dbch\af13\afs28\loch\f4\fs28\lang1036 WW-Heading;}
{\s22\sbasedon0\snext22\ql\widctlpar\sb120\sa120\ltrpar\i\dbch\af8\langfe1033\dbch\af12\afs24\ai\loch\f5\fs24\lang1036 WW-caption;}
{\s23\sbasedon0\snext23\ql\widctlpar\ltrpar\dbch\af8\langfe1033\dbch\af12\afs24\loch\f5\fs24\lang1036 WW-Index;}
{\s24\sbasedon0\snext24\ql\widctlpar\sb120\sa120\ltrpar\i\dbch\af8\langfe1033\dbch\af12\afs24\ai\loch\f5\fs24\lang1036 WW-caption1;}
{\s25\sbasedon0\snext25\ql\widctlpar\sb120\sa120\ltrpar\i\dbch\af8\langfe1033\dbch\af12\afs24\ai\loch\f5\fs24\lang1036 WW-caption11;}
{\s26\sbasedon0\snext26\ql\widctlpar\sb240\sa120\keepn\ltrpar\dbch\af8\langfe1033\dbch\af14\afs28\loch\f7\fs28\lang1036 WW-Heading1;}
{\s27\sbasedon0\snext27\ql\widctlpar\sb120\sa120\ltrpar\i\dbch\af8\langfe1033\dbch\af12\afs24\ai\loch\f5\fs24\lang1036 WW-caption111;}
{\s28\sbasedon0\snext28\ql\widctlpar\ltrpar\dbch\af8\langfe1033\dbch\af12\afs24\loch\f5\fs24\lang1036 WW-Index1;}
{\s29\sbasedon0\snext29\ql\widctlpar\sb120\sa120\ltrpar\i\dbch\af8\langfe1033\dbch\af12\afs24\ai\loch\f5\fs24\lang1036 WW-caption1111;}
}{\info{\creatim\yr2008\mo9\dy13\hr11\min27}{\revtim\yr1601\mo1\dy1\hr0\min0}{\printim\yr1601\mo1\dy1\hr0\min0}{\comment LibreOffice}{\vern4000}}\deftab709
\viewscale100
{\*\pgdsctbl
{\pgdsc0\pgdscuse451\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\pgdscnxt0 Style par d\u233\'e9faut;}}
\formshade{\*\pgdscno0}\paperh16838\paperw11906\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\sectunlocked1\pgndec\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pgndec\pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\alang1025\rtlch \ltrch\loch
Author : Julien GOUESSE, student at the university of science of Paris 6 (well known as Jussieu)}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
This document recapitulates all the modifications these have been made on the former version of the game since the beginning of october 2006.}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab At first, I did a makefile. It may seem to be useless while programming in java but I wanted to be able to compile only the classes whose codes have been modified (intermediary rules), to delete all the files who could be regenerated ("clean" rule) and to create easily a Java archive ("aa.jar" rule). \tab }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Then, I added a method tryToForceGarbageCollection to force the passage of the garbage collector. Indeed, I forced it to finalize objects then I passed a blow of garbage collector. I reiterate as much as I manage to release a little memory. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Afterwards, I withdrew all the methods which go only in an applet: getCodeBase, getParameter, init, start, stop, destroy, getAudioClip\u8230\'26 }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Then, I replaced the applet by a window which is an instance of the Frame class in an application. I then had to use the static method newAudioClip of the Applet class to avoid using applet since I am from now on in an application. I also adapted the code to a local execution. I thus withdrew  useless variables. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Thereafter, I tried to make the code cleaner while starting by withdrawing the \u8220\'1cimport\u8230\'26.*; \u8221\'1d. I wanted to see precisely which classes are used. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Initially, I tried to give the maximum priority to the thread which works at most. After that, I decided to organize the application with only one thread. With this intention, I removed both threads initially. I did it for two reasons: }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- OpenGL has a model with only one thread, certain behaviors are difficult to envisage if one puts oneself in multi-thread for behaviors related to displaying }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- one of both threads makes active waiting and doesn't do almost anything. The thread responsible for the loading of the images consumes much CPU time and does not work all the time when he has the focus whereas the thread of the engine works much and all the time. I could have done one wait () on the thread responsible for the loading of the images since the code of the other thread then to awake with a notify () this last when I require, that would have been enough to avoid that both threads reach some data at the same time, that would have been enough to synchronize them. However, to structure the things thus would complicate the code unnecessarily whereas a simple call to the function runImageLoader () since the engine is more readable and more effective. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab In addition, I realized that the passage of an applet to an application had changed the operation of the loading of the sounds. I then all put them in the principal jar archive so that the application finds them easily. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab After that, I was interested in the full screen mode. Under Linux, it is famous to function very badly, even not at all. I thus envisaged part of the code which goes on the very recent Linux and under Windows (in theory because I did not check) which used the classes GraphicsConfiguration and GraphicsDevice with the method setFullScreenWindow (). In the other cases, I used the method getScreenSize () class Toolkit and I gave to my window the size of the screen. I withdrew decoration with the method setUndecorated () of the Frame class. I placed the window in the top left corner with setLocation. That gave the illusion of the full screen mode. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Let us return into the garbage collector. I realized that I called it only once in the code. I said myself that it would be more adequate to call it with regular intervals. I thus called it once per minute. Then, I said myself that would be well to benefit from one moment when the player does not pay attention with what occurs to call it once again. This is why I call it during each pause of the play. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Then, I realized that the game would be more immersive if I put out the cursor of mouse. I then created a bufferized image of null size with the BufferedImage class. However, the fact of putting null measurements made fall the JVM which requires of me to send a bug report. To circumvent the problem, I created the smallest possible bufferized image, with only one pixel, and I put this pixel at 0 by specifying that this image has a alpha channel. Thus, the bufferized image is transparent. I then put it in a cursor created with createCustomCursor () of the class Toolkit and I put this cursor at the place of the cursor running thanks to the method setCursor () of the Window class. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab Moreover, I added a listener of closure of the window. In SWING, that would not have been necessary thanks to the method setDefaultCloseOperation but I am in AWT. I wanted to build this listener with an anonymous constructor but the JVM did not find the anonymous class when I put it in a jar archive, which was logical since it is not callable. I thus had to create a class which build my listener of closure of the window. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab There, one arrives at the serious things. I finally wished to start to use OpenGL to profit very simply from graphic acceleration and the double buffering at least to display the rendering buffer by temporarily keeping the same technique of treatment of hidden surfaces, the raycasting in fact. I thus undertook to place a GLCanvas in my window. I chose this component because I undoubtedly knew that it works well with AWT and that it fully uses the OpenGL pipelines contrary in GLJPanel (this changed in the JVM 1.6 Mustang build 51 but I still used the JVM 1.5). I used the factory of canvas GLDrawableFactory with this intention. Initially, I prevented the JVM from taking account of the requests of the system to repaint all the window to prevent that decreases the performances largely by often redrawing when it is not necessary. I used the method setIgnoreRepaint of the Component class for this purpose. I then used the methods setDoubleBuffered and setHardwareAccelerated GLCapabilities class to activate the double buffering and graphic acceleration. I also used the method setAutoSwapBufferMode of the GLCanvas class to disable the automatic call with the function display() of the canvas for the same reason as setIgnoreRepaint. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
Once the canvas was ready, I added it to my window. As it implements the GLEventListener interface, I wrote the corresponding methods and I associated the window which acts also as a listener to the canvas. In my method display(), I realized that the method glDrawPixels() requests a nio buffer contrary with its C++ equivalent which requires a table. I tried to create a nio buffer which wraps the table which is used already as buffer of returned with the method wrap of the IntBuffer class. However, my old version of JOGL accepts only nio direct buffers when one is under X11 and wrap returns a nio indirect buffer. I thus tested a beta version of JOGL and this time, that worked. However, I wanted to find an equivalent solution with a nio direct buffer. I thus created a nio direct buffer with the static method newIntBuffer() of the BufferUtil class. The method wrap could not any more thus be used in this case, I decided to copy the table at each iteration. I used the method put() of the IntBuffer class. So that glDrawPixels() dye stick well the pixels of the buffer at the beginning of this one, I move the position of the buffer with 0 with the method position (). But attention! glDrawPixels requires the size by component by pixel and not the size of each pixel. I had put \u8220\'1cGL_INT\u8221\'1d at the beginning whereas it is \u8220\'1cGL_BYTE\u8221\'1d because each component holds on a byte and the 4 components hold then on an entirety of the int type. Yes but my pixels do not need sign then it is rather \u8220\'1cGL_UNSIGNED_BYTE\u8221\'1d. Another problem which arises for me is that I see only the left lower quarter of the play which is positioned with the corner higher right of the screen. I then repositioned the raster with the function glRasterPos and I passed to him (- 1, - 1) like co-ordinates. Then, I see odd colors, as if I had consumed illicit substances what is not my case. I then tested several formats of pixels of which RGBA. In fact, it was necessary to use ABGR. Lastly, I had the head with back bus OpenGL takes for origin the left lower corner and AWT the left higher corner. My method updateRenderbuffer solves this problem by converting the positions from one system to another at the time of the update of the buffer of returned. Another surprise is to have been able to remove an authority of the Image class and another of the MemoryImageSource class which was not used any more for nothing without making plant the JVM thanks to the last version of OpenGL which I chose. Precisely, I left in comments the lines of code which go with other versions of JOGL if I would have to change some. As for the steps on side, they were already available but by maintaining the Shift key inserted with the arrows. I preferred to do without the support of the Shift key in this case. Then, it was necessary to find another solution to turn. Precisely, it is there that I wanted to manage the movements with the mouse. I thus created a class which is used to listen to the movements of the mouse and to reflect the changes on the play. This class implements the MouseMotionListener interface. I could just have asked the principal class of the project to implement this interface but I found that that was not very clean and would have decreased the maintainability of the code, the principal class being with my taste already too large and ass\u251\'fbmant too much responsibility. I thus gave a code to the functions mouseMoved () and mouseDragged (). The code of each one of these functions is the same one since I carry out the same treatment when the mouse moves with or without button of mouse actuated. At this time, the class managed only the movements of the mouse without associating effect the buttons. Moreover, I wanted that the cursor of mouse is centered at the beginning of the play. I thus used the class Robot and more precisely the method mouseMove () to move the cursor since the program even if the documentation of the API java announces that that can not go in the X-Window environments if they decontaminate or XTEST version 2.2 do not support at least. It is also necessary to take account of the centring of in-house cursor so that it is not regarded as a movement of the player. I also envisaged in this class an attribute which makes it possible to activate or not automatic centering. The cursor is automatically centered first once by defect and thereafter, automatic centering prevents especially the cursor especially from reaching the edge of the window according to the attribute corresponding to the margin. This margin corresponds to the number of pixels on the basis of the edge from which one decides to centre the cursor. The cursor should not reach the edge of the window because that would prevent the player from being able to continue to move. I wanted to also manage the shootings with the mouse. This time, that related to the buttons of the mouse, I thus needed to use the MouseListener interface. However, I encountered a problem enough annoying. As soon as I clicked with the mouse, I could not move any more with the keyboard. In fact, I had realized that it was the window which added the ear-phone on the keyboard and which it was the canvas which posed the ear-phones on the mouse. When I click, the events of the keyboard relate to the canvas and either the window! It is that which explained why I lost the control of the player.}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
But then how to make not to oblige the player to click at least once to be able to use the keyboard? Think of the applet which one meets on Internet, that of the play Art Attack on which my project is based for example. Each time, it is necessary to click on the applet to have control with the keyboard. I found a solution. It is enough to use the Robot class once again and to simulate a click since the application with the method mousePress (). This way of making is not widespread in the applet for two reasons: }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- the Robot class is available only since version 1.3 of java and often, the programmers of applet want that their programs run on the greatest number of machines. }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- the flag createRobot must be activated in Security Manager, it is disabled by default for the unsigned applet. By using the MouseListener interface, I could improve the behavior of my GameMouseMotionController class. Thus, if a programmer re-uses my class with a window which does not measure the size of the screen, the fact that the cursor left the window does not give odd results. If automatic centering is activated, with the call of the method mouseExited (), the cursor is centred, if not the movements carried out between the moment when the cursor left the window and moment when it returned are ignored. While trying to draw from the rockets with the mouse, I noticed that one can draw 6 from them at the same time. They are superimposed what does not return very well visually since one does not have the impression to have drawn as much from it and a part of them explodes behind the player. I thus added a mechanism which makes it possible to draw only one salvo from 2 rockets per half second. Let us return in to an aspect closer to the software genius. The video game is programmed \u8220\'1cwith C\u8221\'1d without visibility other than public or the visibility of parcelling. That does not respect the principle of encapsulation of the data, i.e. any attribute of a class is visible since at least all the package. The big problem will arise the day when I would like to make a version network of the play. No matter who will be able rather easily to make turn a class \u8220\'1cto side\u8221\'1d of the miennes to make itself invincible, to increase the damage of his weapons as I will not have any means of seeing what occurs on the side customer from architecture. Even conceptually it is awkward. I thus put a visibility of parcelling for all the methods except the manufacturers who remain of public visibility except that of the principal class which is private. All the attributes of authority and class are private. On the level of the bills of character, I realized that the police force \u8220\'1carial\u8221\'1d is not available on all the machines. I thus decided to choose by defect \u8220\'1cBitstream Vera Without\u8221\'1d and if it is not available, I take the first police force available. I tested the play under Microsoft Windows XP and I had the bad \u8220\'1csurprise\u8221\'1d to see the whole planting as of starting. In fact, the graphic pilots are not very well written, they have sometimes evil to change plug at the time to give up to date posting. I found this solution: try \{canvas.swapBuffers ();\}wrestling (GLException glex) \{glex.printStackTrace ();\} Thus, I avoid planting. The pilots dysfonctionnent especially with the first requests. The other nasty surprise was the dysfunction of TRUTH fullscreen mode even with the JVM 1.6. Ca posts me \u8220\'1cUnable to create OpenGL context\u8221\'1d. While commenting on glDrawPixels () and render (), the play passes from 2 to 30 frames a second! glDrawPixels () (which takes approximately 300 to 500 ms) is necessary as one sends each pixel to the chart after having calculated them with the algorithm of raycasting applied in the method render (). The management of the lights is also voracious in resources, the loading of the images too. This last aspect makes the play less fluid and less regular. I want to thus remove the loading of images during the play. The disadvantage is that the loading will take place at the beginning of the play and risk to be longer. I charge all the images in a table of chopping by associating each file name the corresponding image and I use the mediatrackers to force the complete loading before the beginning of the play. I benefit from it at the same time to make the code sure within the meaning of java 1.5 by specifying what I put in my authorities of the abstract types of data. My modifications enable me to charge the images directly since the files of the repertory pic256 without thus passing by the file \u8220\'1cimages.jar\u8221\'1d the methods dedicated to the loading of images since a file java become useless (doGetImage (), loadImageJar (), getImageJarData ()). It is still necessary that the play updates pseudo-textures immediately, this is why I withdraw the code which requires that 150 ms ago between two up to date handing-over. Although the images are already charged before returning in the principal loop, pseudo-textures are updated in this loop and slowly what is bad impression. When I draw in a wall, it is necessary a few moments so that good under-texture appears. In fact, the method runImageLoader () updates only one under-texture per call, therefore a under-texture every half-second. I modified this behavior so that it as many updates under-textures as necessary quite simply by withdrawing two \u8220\'1cstation-wagon\u8221\'1d in its code. Previously, only \u8220\'1ctouched\u8221\'1d pseudo-textures were updated for less requesting the memory (but by making scientists calculations to decide). By defect now, they very ask to be created with all under-textures which compose them. The method loadTextureSet () is not used more, just as the method uniqueID (). The attributes status (giving the state of the loading), image1 (containing the image in the course of use for creation of a under-texture) and imageid (identifier of the image for the follow-up of loading with the mediatrackers) are not used any more. From now on, I only once call at the beginning of the play the method runImageLoader () which creates all under-textures. I made the same kind of modification with the sound effects and the method stepSoundLoading (). Thus, the sound effects and under-textures are ready before returning in the principal operation iterative of the engine, which avoids rotting the performances. Let us recall that the execution of these methods was considered to be critical. The performances are better and more regular now. I am between 2 and 4 FPS in full screen. The system of calculation of the FPS is a little false. I thus replaced it by a simpler system: FPS = 1000/(temps_maintenant - temps_\u224\'e0_la_frame_pr\u233\'e9c\u233\'e9dente) In fact, without render () nor glDrawPixels (), the play turns to 39 FPS. The play exceeds the 300 FPS when I withdraw the system of light which is extremely heavy. That shows that I have a considerable margin to improve the performances of the play. The captures of screen go but are not practical to use. It is necessary to make the capture then use a tool for conversion to obtain a readable image. The system is heavy and slow. It requires lira in the buffer of pixels. I have two possibilities then: - the method createScreenCapture () of the class Robot and the Write method () of the ImageIO class - the method writeToTargaFile () of the Screenshot class which belongs to the utility classes OpenGL The disadvantages of the first solution are slowness and the impact on the performances. It is also the fact of using the Robot class which can pose problems of permission. The second solution is fast, it is just necessary to take guard to call this method in a method of the GLEventListener interface to be sure to be in the thread which has access to the OpenGL context. I thus write a method performScreenshot () in the principal class and it is the method display () class which implements GLEventListener which calls the method writeToTargaFile (). The method paintBufferString () was simplified and optimized. It rests indirectly on the GLUT. It fills a plug in the class which implements GLEventListener and this class posts the contents of the plug in the method display (). The disadvantage is the weak choice of the type and size of bills of character. The method loadFont () becomes useless. I corrected a bug in my management of the mouse. When I centred the cursor, I induced by error an opposite movement. It is time to charge of the textured and animated models 3D. Being not to reinvent hot water best, I tried to find the format of file more adapted for my play. I initially thought of format OBJ. It is very simple to handle and is well recognized by the modellers but it can manage at the base only static models. One needs several files OBJ to represent an animation. I thus did not choose this format. The format 3DS is very popular and extremely used, it makes it possible to manage the models animated without problem. Nevertheless, even if it is judicious being supported by many modellers, conversions occur sometimes very badly and I do not have 3D MAX. Studio Moreover, it is a format general practitioner, it was not especially thought for a FPS. At this point in time I thought of formats already very much used in the FPS like formats MDL, MD2, MD3 and MD5. I found that there were relatively little specifications and of examples of charger of models to format MDL (used by the play \u8220\'1cHalf Life\u8221\'1d) thus I did not choose it. I found format MD2 rather simple to use but poor enough for what I want to do. Lastly, I decided to take format MD3 rather than format MD5 because I wanted a format which does not force me to use vertexes shaders and pixel shaders and also a format which \u8220\'1cis lived\u8221\'1d not to have too many d\u233\'e9boguage to make so certain important beacons were not recognized basic for example. With format MD3, I can easily make animation by remorphing without using GLSL. I doubt extremely that the computers of the university are equipped with graphics boards supporting the shaders materially, I even know that mine does not do it. Thus, I have a format not too constraining around of which I can build structures of data more worked out for acc\u233\'e9l\u232\'e8rer returned. For example, I can use display lists for the co-ordinates which never change, of the vertexes arrays compiled for co-ordinates which do not change or very little (GL_EXT_compiled_vertex_array) or of simple vertexes arrays for the co-ordinates which often changes, of the vertexes buffer objects even more quickly to manage static and dynamic co-ordinates while going! I thus sought sources of charger and visualisor of models to format MD3 and I found the sources of a tutorial of Digiben in C++. The code of origin was written with the API WIN32 and OpenGL. The code was very well commented on. The problem was that the function which turns over the current hour in milliseconds in C++ (GetTickCount) re-examines a float whereas the method Java currentTimeMillis of the System class returns a long entirety. Because of conversion into float, I realized that I lost too much precision and that the calculation of the time passed between two moments always gave zero. This past time was used to thus calculate the parameter of interpolation my animation was cold. I thus converted the current hour into double rather than in float and that regulated the problem.}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
However, I realized that the tutorial of Digiben was partly false. Calculations of indices were the false thus program planted time with other. As Java raised IndexArrayOutOfBoundException, I knew clearly from where that came contrary to a C++ programmer who is entitled to an error of segmentation, nothing more explicit. The program of Digiben does not support the images using a channel of transparency and the top of the body is badly aligned with bottom. I ended up modifying my way of reading the file of configuration of animation. In fact, I passed certain lines by error and that shifted the co-ordinates of posting. Thereafter, I decided to optimize the layouts by carrying out them in a grouped way. I conceived a whole of classes to check the compatibility of the graphics boards with certain extensions of OpenGL for then tracing the points with the tools most adapted among those available. Initially, it is necessary to arrange each whole of points to be traced in 2 categories according to the frequency of modification of these points: - static unit: together of points unchanged during the execution - unit dynamic: together of points changed during the execution Here various means of tracing points in OpenGL arranged of slowest with fastest: }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- glVertex (primitive by primitive transferred to each master key) }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- vertex arrays (tables of primitives transferred to each master key) }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- display lists (groups of primitives compiled and stored in the VRAM) }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- compiled vertexes arrays (tables of primitives stored in the mask) }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- vertex buffer objects (tables of primitives stored where one wants) }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
In order to standardize the format of storage of the primitives, I could all have arranged in tables (adequate method in C/C++) but JOGL uses much the nio buffers. I thus will avoid using these two structures to save memory together. Moreover, I trace only triangles what simplifies the things enormously. Lastly, I should use neither the display lists nor the vertexes arrays compiled for dynamic sets and I must avoid the simple vertexes arrays for the static sets. After that, I dealt with the deployment of the application with Java Web Start. I hesitated between JOGLAppletLauncher and JAVAWS. It is especially the unreliability of the first which dissuaded me to use it. In fact, even the examples of applet on the site of Sun did not go. To use JAVAWS, should be followed the following stages: }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- gather all the resources of the program in a file gravel bank }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- generate the key with keytool }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- sign this gravel bank with jarsigner }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- upload the gravel bank on the ftp }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- write a file of configuration (at least) for javaws with format JNLP }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- upload this file on the ftp }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- update the Web page so that it contains a bond towards this file }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- to update the Web server (file mime.types under Apache 2) so that it associates the type of application JNLP to JAVAWS }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- to parameterize the navigator so that it launches JAVAWS when I try to open a file of the type JNLP }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
The game had not been designed with an aim of functioning with Java Web Start but rather like a simple offline application. It still used many files on the hard disk apart from the file gravel bank. I thus had to do what is necessary so that it will seek the images, the sounds and the masks in its own gravel bank. Moreover, I had to create a complete Web page. The waiter \u8220\'1clice\u8221\'1d of the university being closed on outside, I had to create a Web site lodged on a free shelterer. Customer ftp accessible since the interface Web from the shelterer does not support the files of more than 200 KB thus I had to use another customer ftp who bears the name of\u8230\'26 ftp, a good customer ftp in line of order under linux. The fire wall of the university prevents me to use it then I must require of comrades of class of uploader the play on my account ftp. The user guide of javaws is incomplete and induces me in error. It was not specified that it was necessary to thus make a file of configuration JNLP by signature I have an error message: \u8220\'1cgravel bank not signed with the same certificate\u8221\'1d. By creating a file for my gander and a file for the gander of bookshop JOGL, I regulate the problem. I benefit from the occasion to clean the code of the system of sounds. I withdraw the methods attach and stepLoadingSound and I eliminate the useless calls to loadSound. }{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
To make the play more accessible, I decided to add a screen of loading. With this intention, I store all the pixels of the image used in a table with a dimension and I correctly place them according to the margins to add if the image is too small. I proceed as follows : }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
x<-(largeur_de_l'\u233\'e9cran - largeur_de_l'image)/2}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
b<-x+largeur_de_l'\u233\'e9cran*(hauteur_de_l'\u233\'e9cran - hauteur_de_l'image)/2}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
pour i de nombre_de_pixels_venant_de_l'image - 1 \u224\'e0 0 faire}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab d\u233\'e9but}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab \tab j<-i+(i/largeur_de_l'image)*2*x+b}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab \tab tableau[j]<-tableau[i]}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab \tab tableau[i]<-0}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
\tab fin}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
finpour}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
The disadvantages of this process is that it thus leaves black bands around the image if it is too small, that it makes disparaitre part of the image when it is too large if one adapts the algorithm in this case. Moreover, Java provides a function which redimensionne an image. This is why I will reinvent hot water and will not use getScale}{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
dInstance. I could also have used the ReplicateScaleFilter class but the result is rather ugly. I could have proceeded as follows: Image image_source=Toolkit.getDefaultToolkit () .createImage (new FilteredImageSource (image_source.getSource (), new ReplicateScaleFilter (screenWidth, screenHeight))); }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
The only advantage of the method above is that it is intrinsically synchronous. Because of difference in reference mark between OpenGL and AWT, my image is with back. I have 3 solutions: }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- AffineTransformOp flipOp=new AffineTransformOp (AffineTransform.getScaleInstance (1, -1) .translate (0,- screenHeight), AffineTransformOp.TYPE_NEAREST_NEIGHBOR); filter ()\u8230\'26 }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- ImageUtil.flipImageVertically (...); }
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
- to use my method updateRenderbuffer simply}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
My last solution thus proves faster I do not complicate the problem.}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\dbch\af10\alang1025\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
There have been too much modifications after this. They are not detailed as I'm tired. I need to have a rest, sorry.}
\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql\rtlch \ltrch\loch

\par \pard\plain \s0\ql\widctlpar\ltrpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\dbch\af8\langfe1033\dbch\af12\afs24\cf0\kerning1\alang1081\loch\f5\fs24\lang1036\ql{\i0\b0\dbch\af10\alang1025\rtlch \ltrch\loch
Finally, I ported the game to JOGL 2.}
\par }